This file will record my ridiculous comment amounts, and data that is linked to my progress redoing the battle code.

STORING DATA:
A minion is represented in the following form:
aMinion = {"ID": int -> the unique number assigned, to prevent multiple of the same name from triggering
           "name": name
           "level": level
           "EXPUntilNextLevel": EXP -> EXP needed to level up
           "types": [type1, type2] -> their types
           "HP": health
           "ATK": attack
           "HEALING": defence
           "ENERGY": energy
           "SPD": speed
           "IntrinsicStatBuff": statType -> the stat the minion specialises in
           "Gems": [[Gem1Buff1], [Gem2Buff1, Gem2Buff2]] -> total equipped gems
           "Moves": ... -> a long list that details each move in the form below, including passives
           "CurrDOTs": [DOTName1, DOTName2] -> list of current DOTs
           "CurrBuffsDeBuffs": [Buff1Name, Debuff1Name] -> list of all received buffs/debuffs
}
Moves v2 representedations:
Move = {ID, name, turnsActive, property1, property2...}
1st div (separating moves) = \n or Newline
2nd div (separating properties) = "," or Comma (CSV)
3rd div is "@" and might not be needed, but nevertheless there in case.

if ID is passive, apply all propertys at start
A property is just a cost/effect done by a move, recorded in this format:

First letter: intial/dot (I/D)
second: target (S/E/A)
third: stat/effect (15 diff values: heal+ damage same sides of coin, same with energycost/restore, so less datapoints)
fourth: val type (literal(!)/percent(%))
fifth: value (incl.positive/negative) i.e -20, 50

example: ISD!-20 -> initially damage self by 20 HP
         DAM!20 -> DOT to allies increases armour by 20 points (it's kinda silly but you get the gist)

alternatively;
first: buff (B)
second: target (S/E/A)
third: stat (what stat is modified)
fourth-sixth: chance: i.e 080, 100, 004
seventh: val type !/%
eigth: value

example: BES075%-25
         Buff enemies' speed by -25% (75% chance)

DOT, by standard, defaults to the set TurnsActive. That should be fine?

Minion (in save file:)
Minion = [ID, name, level, statBonus, gems (list), moveID1, moveID2..]


Minion (in DB):
Minion = [ID, type(s), starting name, HP, ATK, Speed, Energy, Healing, GemMaxAmount, startMovesList]

A move can be shown as:
Move = {
core features
        "name": movename given
        "Type": [moveType1, moveType2] -> what element(s) it is classified as. It can also be "Passive", which denotes the move as a passive buff
        "NumTargets": numTargets -> can be 0-4 for selecting, and at 5 defaults to all. The prefix "A"/"E"/"S" stands for "Allies", "Enemies" or "Self"
        "TurnsActive": numTurnsActive -> number of turns the move acts across
bools
        "VMBuffer": bool -> is there a delay between moves
        "TargetsAreRandom?": bool -> targeting randomly?
buffs
if the below two are just "null", then they are not buffs, simpel!. Buffs and debuffs are part of the same coin, so they can be merged
        "DeBuff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can debuff multiple things, or can possibly do extra debuffs
        "Buff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can buff multiple things, or can possibly do extra buffs
turn manipulation
        "Cooldown": int -> turns before move can be used
        "Exhaust": int -> turns before minion can re-attack
        "Accuracy": 100 (can change) -> chance of hitting (%)
system
        "Icon": image path -> the icon to display
        "MV-Icon": image path -> the in-game move asset
        "MV-Anim": AnimationType -> the animation of the skill    
general
        "MaxMod": [type, MoveForm] -> modifying the maximum of a trait as a buff/debuff
        "Initial": [[stat, MoveForm], [stat, MoveForm]] -> the instant effect of a move, i.e instant ATK, heal, speed, energyrestore, energycost, 
        initial can also have [stat, MoveForm, chance] for buffs/Debuffs
        initial can also have [stat, MoveForm, 100, numTurns] for time-limited buffs/debuffs
        "DOT": [[stat, MoveForm, extraChance, MoveForm, turns], [stat2, MoveForm2, extraChance2, MoveForm3, turns2]] -> all DOTs triggered by this move


ReflectAmount, Armour are all part of Buffs
Stun, Freeze are part of DeBuffs
ATK, CurrHeal, EnrgyCost, EnergyRestore, SpeedMod, Recoil, ClearBuffsDebuffs are now part of "Initial"
Recoil is just "S!-" or "S%-" with the attack var
ClearBuffsDebuffs is used as the "stat" in "Initial", and then the percentage after
HealBaseDOT, HealCritDOT, BaseDOT, CritDOT are part of DOT



GAMEPLAY MECHS

Using OOP for the game:

declare a list of player & enemy minions.

Each minion is now an object to better conceptulaise the playing field.

a minion can also have an "archival" state, where they will not need to play moves but instead just reveal their data


for the moves, they also get a unique object to represented
it acts more like an index than an object, but it's easier conceptually to think of a move as an item instead of  



Gems:

how am i going to store them...

well, gems can be stored in a list like this:
Gem = [Level, [Stat, Value], [Stat, Value]...]
where the level is the current level of the gem
the sublists record which stat and the literal value to modify by.


Noting stuff here (as to why, why not?)

Seems that AllMinionsContainer also has a minion called "BattleMod", that I think is used for the minions that spawn when there are replaced minions

OwnedMinion: will lose my mind looking at it, so here's a brief summary:
IT deals with saving and getting minions, and also with getting/setting values, like crit, health etc 
The helpful areas include (or at least the ones that sound interesting):
IsTalentPointEarnedOnLevel
m_maxTalentPoints
AddShield
SetLevel
GetPassiveIncreasePercentageForStat
CalculateHealingStat
CalculateAttackStat
CalculateCurrStats
CalculateEnergyStat
CalculateSpeedStat
CalculateHealthStat
GetHealthStatDivisor
GetRandomIVs
TickTurn
SetupForCombat

MinionTalentTreeDataNode: Very small, just handles the trees.
The few functions do:
Check if all moves unlocked (DoesTheMinionHaveAllTheMovesInNode)
Resets a tree (ResetNode)
Adds a move to the tree (AddMoveToTree)

BaseMinion: not as painful, but still important
The few functions do:
Adds base moves
gets/sets talent tree
SetSpeacilizaionMoves -> gets unique moves (?)
BaseMinion -> initialises a blank slate for the minion to use 

MinionTalentTree: Also quite small, helps manage the tree. can be ignored/reworked

Gets move dependencies (IsMoveDependantAt)
Gets a move at a spot in an array (GetMovesAt)
Adds moves to the tree (AddMoveToTree)

BaseTalentTreeContainer: a beeg file (10k lines) designed to create the trees. I'll probably store them in a DB

All it does is create the moves, which I can look to the wiki for instead


Some code files seem important:
BaseMoveSystem -> seems to be very important (4k lines)

A basic overview includes:
Queuing Stun/Freeze/Exhaust/Charge animations
ApplyEffectsOfCurrentMove -> actually does a move -> try to analyse
Adding/Removing allies/enemies from TargetsAreRandom
LoadUpTheQueueAndPlayMoves -> around 1k lines of just executing a moves

overall, seems too cumbersome, and hopefully I can rework around it

PlayerMoveSystem, however, seems interesting.
