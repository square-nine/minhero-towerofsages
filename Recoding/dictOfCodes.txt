This file will record my ridiculous comment amounts, and data that is linked to my progress redoing the battle code.

STORING DATA:
A minion is represented in the following form:
aMinion = {"ID": int -> the unique number assigned, to prevent multiple of the same name from triggering
           "name": name
           "level": level
           "EXPUntilNextLevel": EXP -> EXP needed to level up
           "types": [type1, type2] -> their types
           "HP": health
           "ATK": attack
           "HEALING": defence
           "ENERGY": energy
           "SPD": speed
           "IntrinsicStatBuff": statType -> the stat the minion specialises in
           "Gems": [[Gem1Buff1], [Gem2Buff1, Gem2Buff2]] -> total equipped gems
           "Moves": ... -> a long list that details each move in the form below, including passives
           "CurrDOTs": [DOTName1, DOTName2] -> list of current DOTs
           "CurrBuffsDeBuffs": [Buff1Name, Debuff1Name] -> list of all received buffs/debuffs
}
Moves v2 representedations:
Move = {ID, name, turnsActive, property1, property2...}
1st div (separating moves) = \n or Newline
2nd div (separating properties) = "," or Comma (CSV)
3rd div is "@" and might not be needed, but nevertheless there in case.

if ID is passive, apply all propertys at start
A property is just a cost/effect done by a move, recorded in this format:

First letter: intial/dot (I/D)
second: target (S/E/A)
third: stat/effect (15 diff values: heal+ damage same sides of coin, same with energycost/restore, so less datapoints)
fourth: val type (literal(!)/percent(%))
fifth: value (incl.positive/negative) i.e -20, 50

example: ISD!-20 -> initially damage self by 20 HP
         DAM!20 -> DOT to allies increases armour by 20 points (it's kinda silly but you get the gist)

alternatively;
first: buff (B)
second: target (S/E/A)
third: stat (what stat is modified)
fourth-sixth: chance: i.e 080, 100, 004
seventh: val type !/%
eigth: value

example: BES075%-25 -> Buff enemies speed by -25% at a 75% chance

DOT, by standard, defaults to the set TurnsActive. That should be fine?

Minion (in save file:)
Minion = [ID, name, level, statBonus, gems (list), moveID1, moveID2..]


Minion (in DB):
Minion = [ID, type(s), starting name, HP, ATK, Speed, Energy, Healing, GemMaxAmount, startMovesList]

A move can be shown as:
Move = {
core features
        "name": movename given
        "Type": [moveType1, moveType2] -> what element(s) it is classified as. It can also be "Passive", which denotes the move as a passive buff
        "NumTargets": numTargets -> can be 0-4 for selecting, and at 5 defaults to all. The prefix "A"/"E"/"S" stands for "Allies", "Enemies" or "Self"
        "TurnsActive": numTurnsActive -> number of turns the move acts across
bools
        "VMBuffer": bool -> is there a delay between moves
        "TargetsAreRandom?": bool -> targeting randomly?
buffs - if the below two are just "null", then they are not buffs, simpel!. Buffs and debuffs are part of the same coin, so they can be merged
        "DeBuff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can debuff multiple things, or can possibly do extra debuffs
        "Buff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can buff multiple things, or can possibly do extra buffs
turn manipulation - removed as integrated into general
system
        "Icon": image path -> the icon to display
        "MV-Icon": image path -> the in-game move asset
        "MV-Anim": AnimationType -> the animation of the skill    
general
        "MaxMod": [type, MoveForm] -> modifying the maximum of a trait as a buff/debuff
        "Initial": [[stat, MoveForm], [stat, MoveForm]] -> the instant effect of a move, i.e instant ATK, heal, speed, energyrestore, energycost, 
        initial can also have [stat, MoveForm, chance] for buffs/Debuffs
        initial can also have [stat, MoveForm, 100, numTurns] for time-limited buffs/debuffs
        "DOT": [[stat, MoveForm, extraChance, MoveForm, turns], [stat2, MoveForm2, extraChance2, MoveForm3, turns2]] -> all DOTs triggered by this move


ReflectAmount, Armour are all part of Buffs
Stun, Freeze are part of DeBuffs
ATK, CurrHeal, EnrgyCost, EnergyRestore, SpeedMod, Recoil, ClearBuffsDebuffs are now part of "Initial"
Recoil is just "S!-" or "S%-" with the attack var
ClearBuffsDebuffs is used as the "stat" in "Initial", and then the percentage after
HealBaseDOT, HealCritDOT, BaseDOT, CritDOT are part of DOT



GAMEPLAY MECHS

Using OOP for the game:

declare a list of player & enemy minions.

Each minion is now an object to better conceptulaise the playing field.

a minion can also have an "archival" state, where they will not need to play moves but instead just reveal their data


for the moves, they also get a unique object to represented
it acts more like an index than an object, but it's easier conceptually to think of a move as an item instead of  



Gems:

how am i going to store them...

well, gems can be stored in a list like this:
Gem = [Level, [Stat, Value], [Stat, Value]...]
where the level is the current level of the gem
the sublists record which stat and the literal value to modify by.


Noting stuff here (as to why, why not?)

Seems that AllMinionsContainer also has a minion called "BattleMod", that I think is used for the minions that spawn when there are replaced minions

OwnedMinion: will lose my mind looking at it, so here's a brief summary:
IT deals with saving and getting minions, and also with getting/setting values, like crit, health etc 
The helpful areas include (or at least the ones that sound interesting):
IsTalentPointEarnedOnLevel
m_maxTalentPoints
AddShield
SetLevel
GetPassiveIncreasePercentageForStat
CalculateHealingStat
CalculateAttackStat
CalculateCurrStats
CalculateEnergyStat
CalculateSpeedStat
CalculateHealthStat
GetHealthStatDivisor
GetRandomIVs
TickTurn
SetupForCombat

MinionTalentTreeDataNode: Very small, just handles the trees.
The few functions do:
Check if all moves unlocked (DoesTheMinionHaveAllTheMovesInNode)
Resets a tree (ResetNode)
Adds a move to the tree (AddMoveToTree)

BaseMinion: not as painful, but still important
The few functions do:
Adds base moves
gets/sets talent tree
SetSpeacilizaionMoves -> gets unique moves (?)
BaseMinion -> initialises a blank slate for the minion to use 

MinionTalentTree: Also quite small, helps manage the tree. can be ignored/reworked

Gets move dependencies (IsMoveDependantAt)
Gets a move at a spot in an array (GetMovesAt)
Adds moves to the tree (AddMoveToTree)

BaseTalentTreeContainer: a beeg file (10k lines) designed to create the trees. I'll probably store them in a DB

All it does is create the moves, which I can look to the wiki for instead


Some code files seem important:
BaseMoveSystem -> seems to be very important (4k lines)

A basic overview includes:
Queuing Stun/Freeze/Exhaust/Charge animations
ApplyEffectsOfCurrentMove -> actually does a move -> try to analyse
Adding/Removing allies/enemies from TargetsAreRandom
LoadUpTheQueueAndPlayMoves -> around 1k lines of just executing a moves

overall, seems too cumbersome, and hopefully I can rework around it

PlayerMoveSystem, however, seems interesting.


Now i can see the light (by exporting properly), time to looksee

Within Singleton.StaticData.CalculateDamageOrHealingAmount:

For damage
Takes in 5 parameters:
1: Current move damage
2: Current additional random damage
3: Current minion's max attack stat
4: Current minion's level
5: [defaults to False] 

For healing
Takes in 5 parameters:
1: Current move heal amount
2: Current additional random healing
3: Current minion's max healing stat
4: Current minion's level
5: [defaults to False] 

For shielding
Takes in 5 parameters:
1: Current move shield amount
2: [defaults to zero]
3: Current minion's max healing stat
4: Current minion's level
5: [defaults to True] 

All use the same formula, which is:

l7 = param1 + param2*math.random()
l10 = (_loc10_ = (_loc10_ = (_loc10_ = (_loc10_ = param4 * 3 / 5 + 2) * l7) * param3) * 1) / 3000
the above long formula simplifies into:
l10 = ((param4 *3/5 + 2)*l7)*param3/3000

so, in eenglis:

multiply the level by 3/5, and then add 2
then multiple by (current amount + (extra amount * random between 0-1))
then multiply by max stat and divide by 3000

i guess?


Within BaseMoveSystem.ApplyEffectsOfCurrentMove:
more of a half-shitpost half-logic, trust it will be cleared up hopefully later

first, setup vars to use basically placeholders:
var _loc4_:Number = NaN;
var _loc5_:Number = NaN;
var _loc6_:Number = NaN;
var _loc12_:Number = NaN;
var _loc13_:int = 0;
var _loc14_:Number = NaN;
var _loc15_:int = 0;
var _loc16_:int = 0;

then, subtract energy from minion by the amount of energy cost
then, if the energy restoring amount is > 0 (i.e exists), then this.m_currMinion.m_currEnergy += this.m_currMinion.m_currEnergyStat * (this.m_currMove.m_energyPercentageRestored / 100)
then, if the accuracy is less than the "apply miss chance" var, then just return. Essentially  skipping everything else.
if continuing:
set the minion's exhaust time to the move's exhaust time
set l1 to the damage
set l2 to the healing amount
set l3 to the shield amount
then, if the minion's types equal the move's type, then apply a stab modifier (1.1x) to l1 and l2 
setup more vars:
var _loc7_:Number = 1
var _loc8_:Vector.<OwnedMinion> = new Vector.<OwnedMinion>() # the minion to receive damage
var _loc9_:Number = 0
var _loc10_:int = 0  #for the for loop

SEARCH FOR ANY MINIONS THAT REDIRECT DAMAGE
now, while _loc10_ < 5:
 if the this.m_isPlayerMoveSystem is true (i.e if its the player's turn to attack):
  if there is a minion at index _loc10_ and their health is above zero:
  if target's redirect damage is above zero:
  set loc8 to the opponent minion
  add redirect damage to _loc9_
  if the move damage is above zero or there is additional random damage:
  play a redirect animation of the target minion
  
 else if(Singleton.dynamicData.GetOwnedMinionAt(_loc10_) != null && Singleton.dynamicData.GetOwnedMinionAt(_loc10_).m_currHealth > 0)
 or: if instead, there is an owned minion at that position and their health is above zero (i.e the enemie's turn and you got a minion able to be targeted)
  if your minion has redirect damage
  set loc8 to that minion
  set loc9 to the redirect damage
  if the move damage is not zero or there is random damage:
  play a redirect animation of the target minion
 
  then increase loc10 by one (progress loop)

now make loc11 exist as 0

while loc11 is less than the number of enemies it hits:
 make loc4 equal to loc1, for some reason 
 if ((_loc7_ = (_loc7_ = (_loc7_ = 1) * Singleton.staticData.CalculateEffectivenessModifier(this.m_currMove.m_moveType,this.m_enemiesItHits[_loc11_].m_baseMinion.m_minionType1)) * Singleton.staticData.CalculateEffectivenessModifier(this.m_currMove.m_moveType,this.m_enemiesItHits[_loc11_].m_baseMinion.m_minionType2)) > 1.4)
 which means, i think if you multiply the effectiveness and check if it's > 1.4
        then play the super effective animation
 if it's instead < 0.7
         then play the not effective modifier
 multiply loc4 by loc7 
 if the crit chance is above random*100
         double loc4
         play critical animation 
 divide loc9 by 100
 loc12 equals loc4 now
 loc13 exists now as zero
 while loc13 is less than len(loc8):
  loc14 is equal to the ((loc13)th index of loc8) current redirect damage property divided by 100
  if loc9 is larger than 1:
   loc15 is equal to loc12 * (loc14/loc9)
  if not:
  loc15 is equal to loc12*loc14
  loc4 gets minused by loc15
  add to the current minion the health (loc15 *-1* [loc11]th index of enemy reflect damage percent)
  multiply loc15 by _loc8_[_loc13_].m_currArmorModRate
  add loc15 * -1 HP to _loc8_[_loc13_]
  loc13 += 1
 
 now do this.m_currMinion.AddToHealth(-_loc4_ * this.m_enemiesItHits[_loc11_].m_currReflectDamagePercentage) 
 ahh so then apply any damage to self due to the reflect of the minion.
 then loc4 is multiplied by this.m_enemiesItHits[_loc11_].m_currArmorModRate (the armour of the enemy)
 then this.m_enemiesItHits[_loc11_].AddToHealth(-_loc4_) (remove loc4 worth of health from current enemy)
 if this.m_currMove.m_DOTDamage > 0 || this.m_currMove.m_additionalDOTDamage > 0 || this.m_currMove.m_armor != 0 || this.m_currMove.m_setReflectDamageAmount > 0:
 or: if the DOT damage is above 0 or the additional DOT damage is > 0 or the current move's armour is not 0 or if the move sets a reflect amount > 0:
  if the enemy doesn't have a mod shield:
   Add the DOT to the current enemy minion using AddDotOrHot(current move ID, current minion)
if the ClearBuffsAndDebuffs chance is above random*100:
 clear the minions buffs and debuffs
if the current move's freeze chance is above this.m_freezeChance (??):
 set the current enemy minion to frozen, and set the number of turns of it to zero
 adjust the tint to 3381759 by 0.5 for the enemy current minion, using the TweenLite module
if the current move's stun chance is above this.m_stunChance (??):
 set the current enemy minion to stunned
 adjust the tint to 16777062 by 0.5 for the enemy current minion using the TweenLite module

 increase loc11 by +1

reset loc11 to zero
while loc11 is less than the number of allies it hits:
 _loc5_ = _loc2_
 _loc6_ = _loc3_
 if (_loc7_ = (_loc7_ = (_loc7_ = 1) * Singleton.staticData.CalculateHealingEffectivenessModifier(this.m_currMove.m_moveType,this.m_alliesItHits[_loc11_].m_baseMinion.m_minionType1)) * Singleton.staticData.CalculateHealingEffectivenessModifier(this.m_currMove.m_moveType,this.m_alliesItHits[_loc11_].m_baseMinion.m_minionType2)) > 1.4 && _loc5_ > 0)
 or: if Singleton.staticData.CalculateHealingEffectivenessModifier(this.m_currMove.m_moveType,this.m_alliesItHits[_loc11_].m_baseMinion.m_minionType1) * Singleton.staticData.CalculateHealingEffectivenessModifier(this.m_currMove.m_moveType,this.m_alliesItHits[_loc11_].m_baseMinion.m_minionType2) > 1.4 and loc5 is above zero
 or: if the product of the healing effectiveness modifiers due to the move and the target ally's first and second types is larger than 1.4 and if loc5 is larger than zero:
  play the super effective animation
 else if that product is less than 0.7 and loc5 is greater than zero:
  play the not effective animation
 multiply loc5 by loc7
 if the current minion's crit chance is larger than random *100:
  double loc5, and if that's larger than zero:
   play crit hit animation 
 heal the current ally by loc5 amount
 shield the current ally by the amount in loc6 
 if the chance to clear buffs and debuffs is larger than random*100:
  clear that ally's buffs and debuffs
 if the move's HOThealing is above zero, or the additional HOT healing is above zero, or the move's armour is not zero, or the amount to set reflect damage is above zero
  use AddDotOrHot(current move ID, current minion) on the current ally
 loc11 += 1

now loc1 = Singleton.staticData.CalculateDamageOrHealingAmount(this.m_currMove.m_selfDamage,this.m_currMove.m_additionalRandomSelfDamage,this.m_currMinion.m_maxAttackStat,this.m_currMinion.m_currLevel)
which just makes loc1 equal the damage or healing amount using CalculateDamageOrHealingAmount, with params of move's self damage, self random additional damage, current minion's ATKstat, current level
now subtract loc1 from the current minion's health (i.e calculate the initial self damage)
now subtract -(this.m_currMove.m_selfPercentageDamage / 100) * this.m_currMinion.m_currHealthStat from the current minions health (i.e percentage damage)
loc2 equals Singleton.staticData.CalculateDamageOrHealingAmount(this.m_currMove.m_selfHeal,this.m_currMove.m_additionalRandomSelfHeal,this.m_currMinion.m_maxHealingStat,this.m_currMinion.m_currLevel)
which just means to find the self healing amount of the move due to the level+stat of minion
add loc2 to the current minion
if the cooldown time is above zer (i.e cooldown exists):
 add the moveID to the current minion's cooldowns
if the move does buff itself:
 loc16 equals zero
 while loc16 is less than len(move's stat types to buff):
  if the apply buff chance is less than current move's chance to buff:
   this.m_currMinion.AddToStatStages(this.m_currMove.m_statTypesToBuff[_loc16_],this.m_currMove.m_stagesOfStatTypeToBuff)
   or: add to the stats the buff amount at the loc16th index and also the the buff amount recorded in the current move
  loc16 += 1

if the move does debuff itself:
 do the same as if it buffed itself, except replacing debuff with buff

if the move does buff targets:
 for loc11 in range(0, len(alliesItHits)):
  do the same as if it buffed itself, except replace current minion with the loc11th index of alliesItHits
 repeat the above except replace allies with enemies

if the move does debuff targets:
 do the same as if it does buff targets but replace all cases of buffing with debuffing

then, update the minion's health

 

Now to make sense of this as Python...................................................

OKAY PLS NOT This
i guess I will just code with da flow, only way for it to work properly


1. Setups
_loc4_ = None
_loc5_ = None
_loc6_ = None
_loc12_ = None
_loc13_ = 0
_loc14_ = None
_loc15_ = 0
_loc16_ = 0

then, subtract energy from minion by the amount of energy cost
so, currMinion.energy -= currMove.energycost
then, add energy from minion by percentage amount if that property exists
so, if (currMove.energyPercentRestored > 0): currMinion.energy += currMinion.energyStat * currMove.energyPercentRestored /100

if the accuracy is below the chance to miss (global chance for the move)
return and stop playing the moves.

currMinion.exhaust = currMove.exhaustAmount

2. Get common properties (Damage, Heal, Shield)
_loc1_ = CalcDamageOrHealing(currMove.damage, currMove.AdditionalDamage, currMinion.maxATK, currMinion.level)
_loc2_ = CalcDamageOrHealing(currMove.healing, currMove.AdditionalHealing, currMinion.maxHeal, currMinion.level)
_loc3_ = CalcDamageOrHealing(currMove.ShieldAmount, 0, currMinion.maxHeal, currMinion.level, false)

if either minion type equals the move's moveType1
so if currMinion.type1 == currMove.type OR currMinion.type2 == currMove.type:
 loc1 *= 1.1
 loc2 *= 1.1

setup more vars:
var _loc7_:Number = 1
var _loc8_:Vector.<OwnedMinion> = new Vector.<OwnedMinion>() # the minion to receive damage
var _loc9_:Number = 0

Get redireting minion.
for loc10 in range(5):
 if it is the player's move:
  if there is an opponent at position loc10 and it has health above zero:
   if that minion has redirect damage:
    loc8 gets  added with that minion
    loc9 += that minion's redirect damage
    if the current move's damage is above zero or there is additional random damage:
     play a redirected animation
 else if the player has a minion at position loc10 and its health is above zero:
  if that minion has redirect damage above zero:

  
 