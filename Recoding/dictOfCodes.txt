This file will record my ridiculous comment amounts, and data that is linked to my progress redoing the battle code.

STORING DATA:
A minion is represented in the following form:
aMinion = {"ID": int -> the unique number assigned, to prevent multiple of the same name from triggering
           "name": name
           "level": level
           "EXPUntilNextLevel": EXP -> EXP needed to level up
           "types": [type1, type2] -> their types
           "HP": health
           "ATK": attack
           "HEALING": defence
           "ENERGY": energy
           "SPD": speed
           "IntrinsicStatBuff": statType -> the stat the minion specialises in
           "Gems": [[Gem1Buff1], [Gem2Buff1, Gem2Buff2]] -> total equipped gems
           "Moves": ... -> a long list that details each move in the form below, including passives
           "CurrDOTs": [DOTName1, DOTName2] -> list of current DOTs
           "CurrBuffsDeBuffs": [Buff1Name, Debuff1Name] -> list of all received buffs/debuffs
}
Moves v2 representedations:
Move = {ID, name, turnsActive, property1, property2...}
1st div (separating moves) = \n or Newline
2nd div (separating properties) = "," or Comma (CSV)
3rd div is "@" and might not be needed, but nevertheless there in case.

if ID is passive, apply all propertys at start
A property is just a cost/effect done by a move, recorded in this format:

First letter: intial/dot (I/D)
second: target (S/E/A)
third: stat/effect (15 diff values: heal+ damage same sides of coin, same with energycost/restore, so less datapoints)
fourth: val type (literal(!)/percent(%))
fifth: value (incl.positive/negative) i.e -20, 50

example: ISD!-20 -> initially damage self by 20 HP
         DAM!20 -> DOT to allies increases armour by 20 points (it's kinda silly but you get the gist)

alternatively;
first: buff (B)
second: target (S/E/A)
third: stat (what stat is modified)
fourth-sixth: chance: i.e 080, 100, 004
seventh: val type !/%
eigth: value

example: BES075%-25 -> Buff enemies speed by -25% at a 75% chance

DOT, by standard, defaults to the set TurnsActive. That should be fine?

Minion (in save file:)
Minion = [ID, name, level, statBonus, gems (list), moveID1, moveID2..]


Minion (in DB):
Minion = [ID, type(s), starting name, HP, ATK, Speed, Energy, Healing, GemMaxAmount, startMovesList]

A move can be shown as:
Move = {
core features
        "name": movename given
        "Type": [moveType1, moveType2] -> what element(s) it is classified as. It can also be "Passive", which denotes the move as a passive buff
        "NumTargets": numTargets -> can be 0-4 for selecting, and at 5 defaults to all. The prefix "A"/"E"/"S" stands for "Allies", "Enemies" or "Self"
        "TurnsActive": numTurnsActive -> number of turns the move acts across
bools
        "VMBuffer": bool -> is there a delay between moves
        "TargetsAreRandom?": bool -> targeting randomly?
buffs - if the below two are just "null", then they are not buffs, simpel!. Buffs and debuffs are part of the same coin, so they can be merged
        "DeBuff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can debuff multiple things, or can possibly do extra debuffs
        "Buff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can buff multiple things, or can possibly do extra buffs
turn manipulation - removed as integrated into general
system
        "Icon": image path -> the icon to display
        "MV-Icon": image path -> the in-game move asset
        "MV-Anim": AnimationType -> the animation of the skill    
general
        "MaxMod": [type, MoveForm] -> modifying the maximum of a trait as a buff/debuff
        "Initial": [[stat, MoveForm], [stat, MoveForm]] -> the instant effect of a move, i.e instant ATK, heal, speed, energyrestore, energycost, 
        initial can also have [stat, MoveForm, chance] for buffs/Debuffs
        initial can also have [stat, MoveForm, 100, numTurns] for time-limited buffs/debuffs
        "DOT": [[stat, MoveForm, extraChance, MoveForm, turns], [stat2, MoveForm2, extraChance2, MoveForm3, turns2]] -> all DOTs triggered by this move


ReflectAmount, Armour are all part of Buffs
Stun, Freeze are part of DeBuffs
ATK, CurrHeal, EnrgyCost, EnergyRestore, SpeedMod, Recoil, ClearBuffsDebuffs are now part of "Initial"
Recoil is just "S!-" or "S%-" with the attack var
ClearBuffsDebuffs is used as the "stat" in "Initial", and then the percentage after
HealBaseDOT, HealCritDOT, BaseDOT, CritDOT are part of DOT



GAMEPLAY MECHS

Using OOP for the game:

declare a list of player & enemy minions.

Each minion is now an object to better conceptulaise the playing field.

a minion can also have an "archival" state, where they will not need to play moves but instead just reveal their data


for the moves, they also get a unique object to represented
it acts more like an index than an object, but it's easier conceptually to think of a move as an item instead of  



Gems:

how am i going to store them...

well, gems can be stored in a list like this:
Gem = [Level, [Stat, Value], [Stat, Value]...]
where the level is the current level of the gem
the sublists record which stat and the literal value to modify by.


Noting stuff here (as to why, why not?)

Seems that AllMinionsContainer also has a minion called "BattleMod", that I think is used for the minions that spawn when there are replaced minions

OwnedMinion: will lose my mind looking at it, so here's a brief summary:
IT deals with saving and getting minions, and also with getting/setting values, like crit, health etc 
The helpful areas include (or at least the ones that sound interesting):
IsTalentPointEarnedOnLevel
m_maxTalentPoints
AddShield
SetLevel
GetPassiveIncreasePercentageForStat
CalculateHealingStat
CalculateAttackStat
CalculateCurrStats
CalculateEnergyStat
CalculateSpeedStat
CalculateHealthStat
GetHealthStatDivisor
GetRandomIVs
TickTurn
SetupForCombat

MinionTalentTreeDataNode: Very small, just handles the trees.
The few functions do:
Check if all moves unlocked (DoesTheMinionHaveAllTheMovesInNode)
Resets a tree (ResetNode)
Adds a move to the tree (AddMoveToTree)

BaseMinion: not as painful, but still important
The few functions do:
Adds base moves
gets/sets talent tree
SetSpeacilizaionMoves -> gets unique moves (?)
BaseMinion -> initialises a blank slate for the minion to use 

MinionTalentTree: Also quite small, helps manage the tree. can be ignored/reworked

Gets move dependencies (IsMoveDependantAt)
Gets a move at a spot in an array (GetMovesAt)
Adds moves to the tree (AddMoveToTree)

BaseTalentTreeContainer: a beeg file (10k lines) designed to create the trees. I'll probably store them in a DB

All it does is create the moves, which I can look to the wiki for instead


Some code files seem important:
BaseMoveSystem -> seems to be very important (4k lines)

A basic overview includes:
Queuing Stun/Freeze/Exhaust/Charge animations
ApplyEffectsOfCurrentMove -> actually does a move -> try to analyse
Adding/Removing allies/enemies from TargetsAreRandom
LoadUpTheQueueAndPlayMoves -> around 1k lines of just executing a moves

overall, seems too cumbersome, and hopefully I can rework around it

PlayerMoveSystem, however, seems interesting.


Now i can see the light (by exporting properly), time to looksee

Within Singleton.StaticData.CalculateDamageOrHealingAmount:

For damage
Takes in 5 parameters:
1: Current move damage
2: Current additional random damage
3: Current minion's max attack stat
4: Current minion's level
5: [defaults to False] 

For healing
Takes in 5 parameters:
1: Current move heal amount
2: Current additional random healing
3: Current minion's max healing stat
4: Current minion's level
5: [defaults to False] 

For shielding
Takes in 5 parameters:
1: Current move shield amount
2: [defaults to zero]
3: Current minion's max healing stat
4: Current minion's level
5: [defaults to True] 

All use the same formula, which is:

l7 = param1 + param2*math.random()
l10 = (_loc10_ = (_loc10_ = (_loc10_ = (_loc10_ = param4 * 3 / 5 + 2) * l7) * param3) * 1) / 3000
the above long formula simplifies into:
l10 = ((param4 *3/5 + 2)*l7)*param3/3000

so, in eenglis:

multiply the level by 3/5, and then add 2
then multiple by (current amount + (extra amount * random between 0-1))
then multiply by max stat and divide by 3000

i guess?


Within BaseMoveSystem.ApplyEffectsOfCurrentMove:
logical talk about it:
first, setup vars to use:
var _loc4_:Number = NaN;
var _loc5_:Number = NaN;
var _loc6_:Number = NaN;
var _loc12_:Number = NaN;
var _loc13_:int = 0;
var _loc14_:Number = NaN;
var _loc15_:int = 0;
var _loc16_:int = 0;

then, subtract energy from minion by the amount of energy cost
then, if the energy restoring amount is > 0 (i.e exists), then this.m_currMinion.m_currEnergy += this.m_currMinion.m_currEnergyStat * (this.m_currMove.m_energyPercentageRestored / 100)
then, if the accuracy is less than the "apply miss chance" var, then just return and SetupForCombat
if continuing:
set the minion's exhaust time to the move's exhaust time
set l1 to the damage
set l2 to the healing amount
set l3 to the shield amount
then, if the minion's types equal the move's type, then apply a stab modifier (1.1x) to l1 and l2 
setup more vars:
var _loc7_:Number = 1;
var _loc8_:Vector.<OwnedMinion> = new Vector.<OwnedMinion>();
var _loc9_:Number = 0;
var _loc10_:int = 0;

SEARCH FOR ANY MINIONS THAT REDIRECT DAMAGE
now, while _loc10_ < 5:
if the this.m_isPlayerMoveSystem is true (i.e if its the player's turn to attack):
 if there is a minion at index _loc10_ and their health is above zero:
 if target's redirect damage is above zero:
 set loc8 to the opponent minion
 add redirect damage to _loc9_
 if the move damage is above zero or there is additional random damage:
 play a redirect animation of the target minion
 
else if(Singleton.dynamicData.GetOwnedMinionAt(_loc10_) != null && Singleton.dynamicData.GetOwnedMinionAt(_loc10_).m_currHealth > 0)
or: if instead, there is an owned minion at that position and their health is above zero (i.e the enemie's turn and you got a minion able to be targeted)
 if your minion has redirect damage
 set loc8 to that minion
 set loc9 to the redirect damage
 if the move damage is not zero or there is random damage:
 play a redirect animation of the target minion

then increase loc10 by one (progress loop)


now make loc11 exist as 0

while loc11 is less than the number of enemies it hits:
 
 I'M ON LINE 476 OF DECODING BASEMOVESYSTEM
