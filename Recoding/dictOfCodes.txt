This file will record my ridiculous comment amounts



STORING DATA:
A minion is represented in the following form:
aMinion = {"ID": int -> the unique number assigned, to prevent multiple of the same name from triggering
           "name": name
           "level": level
           "EXPUntilNextLevel": EXP -> EXP needed to level up
           "types": [type1, type2] -> their types
           "HP": health
           "ATK": attack
           "HEALING": defence
           "ENERGY": energy
           "SPD": speed
           "IntrinsicStatBuff": statType -> the stat the minion specialises in
           "Gems": [[Gem1Buff1], [Gem2Buff1, Gem2Buff2]] -> total equipped gems
           "Moves": ... -> a long list that details each move in the form below, including passives
           "CurrDOTs": [DOTName1, DOTName2] -> list of current DOTs
           "CurrBuffsDeBuffs": [Buff1Name, Debuff1Name] -> list of all received buffs/debuffs

}


Moves v2 representedations:
Move = {ID, name, property1, property2...}

if ID is passive, apply all propertys at start

A property is just a cost/effect done by a move, recorded in this format:

First letter: intial/dot (I/D)
second: target (S/E/A)
third: stat/effect (15 diff values: heal+ damage same sides of coin, same with energycost/restore, so less datapoints)
fourth: val type (literal(!)/percent(%))
fifth: value (incl.positive/negative) i.e -20, 50

example: ISD!-20 -> initially damage self by 20 HP
         DAM!20 -> DOT to allies increases armour by 20 points (it's kinda silly but you get the gist)

alternatively;
first: buff (B)
second: target (S/E/A)
third: stat (what stat is modified)
fourth-sixth: chance: i.e 080, 100, 004
seventh: val type !/%
eigth: value

example: BES075%-25
         Buff enemies' speed by -25% (75% chance)

DOT, by standard, defaults to the set TurnsActive. That should be fine?



Minion (in save file:)
Minion = [ID, name, level, statBonus, gems (list), moveID1, moveID2..]


Minion (in DB):
Minion = [ID, type(s), starting name, HP, ATK, Speed, Energy, Healing, GemMaxAmount, startMovesList]

A move can be shown as:
Move = {
core features
        "name": movename given
        "Type": [moveType1, moveType2] -> what element(s) it is classified as. It can also be "Passive", which denotes the move as a passive buff
        "NumTargets": numTargets -> can be 0-4 for selecting, and at 5 defaults to all. The prefix "A"/"E"/"S" stands for "Allies", "Enemies" or "Self"
        "TurnsActive": numTurnsActive -> number of turns the move acts across
bools
        "VMBuffer": bool -> is there a delay between moves
        "TargetsAreRandom?": bool -> targeting randomly?
buffs
if the below two are just "null", then they are not buffs, simpel!. Buffs and debuffs are part of the same coin, so they can be merged
        "DeBuff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can debuff multiple things, or can possibly do extra debuffs
        "Buff": [[type, chance, MoveForm1], [type2, chance2, MoveForm2]] -> can buff multiple things, or can possibly do extra buffs
turn manipulation
        "Cooldown": int -> turns before move can be used
        "Exhaust": int -> turns before minion can re-attack
        "Accuracy": 100 (can change) -> chance of hitting (%)
system
        "Icon": image path -> the icon to display
        "MV-Icon": image path -> the in-game move asset
        "MV-Anim": AnimationType -> the animation of the skill    
general
        "MaxMod": [type, MoveForm] -> modifying the maximum of a trait as a buff/debuff
        "Initial": [[stat, MoveForm], [stat, MoveForm]] -> the instant effect of a move, i.e instant ATK, heal, speed, energyrestore, energycost, 
        initial can also have [stat, MoveForm, chance] for buffs/Debuffs
        initial can also have [stat, MoveForm, 100, numTurns] for time-limited buffs/debuffs
        "DOT": [[stat, MoveForm, extraChance, MoveForm, turns], [stat2, MoveForm2, extraChance2, MoveForm3, turns2]] -> all DOTs triggered by this move


ReflectAmount, Armour are all part of Buffs
Stun, Freeze are part of DeBuffs
ATK, CurrHeal, EnrgyCost, EnergyRestore, SpeedMod, Recoil, ClearBuffsDebuffs are now part of "Initial"
Recoil is just "S!-" or "S%-" with the attack var
ClearBuffsDebuffs is used as the "stat" in "Initial", and then the percentage after
HealBaseDOT, HealCritDOT, BaseDOT, CritDOT are part of DOT



GAMEPLAY MECHS

Using OOP for the game:

declare a list of player & enemy minions.

Each minion is now an object
the constructor may look like this, for a game-ready minion:
def __init__(self, ID, name, level, statBonus, gems, moves, currEXP):
        self.ID = ID  #unique identifier for a minion
        self.name = name #the name given
        self._level = level #the current level
        self._currEXP = currEXP #the EXP within the level
        self._gems = gems #the equipped gems
        self._moveIDList = moves #the IDs of all available moves

        #-----
        #process ID to get the below stats, including modifying for statBonus, gems, and level
        self.HP = health
        self.ATK = attack
        self.energy = energy
        self.speed = speed
        self.healing = healing

        #------
        #other game constants

        self.currEffects = [] #a list containing all temporary boosts

private functions will need to be:

PlayMove(self, moveID) -> actually does a move
ProcessMoveIDList(self) -> converts MoveIDs in a list into Move objects

a minion can also have an "archival" state, where they will not need to play moves but instead just reveal their data


for the moves, they also get a unique object to represented
it acts more like an index than an object, but it's easier conceptually to think of a move as an item instead of  
def __init__(self, ID):
        self.ID = ID #the unique ID of the move

        #------
        #process the move to get the details
        self.initial = initials
        self.DOT = DOTs
        self.buffs = buffs
        self.type = types
        self.name = name

some functions include:
IDToStats(self), converts the ID into the required stats




def ExampleMove():
    def __init__(self, ID):
        self.ID = ID
        #time to get data about this specific move: loads data from a specified move into self.currMove
        #find in db
        MovesDB = ProcessDB(self, "ChoooseAPATHSOON") #placeholder for loading the database
        for item in MovesDB: #for each move
            if item[0] == ID: #if the IDs match
                if ID <= 115: self.type = "PASSIVE" #get the move type :saves me a column in the DB
                elif 115 < ID <= 190: self.type = "NORMAL"
                elif 190 < ID <= 225: self.type = "FLYING"
                elif 225 < ID <= 285: self.type = "PLANT"
                elif 285 < ID <= 330: self.type = "WATER"
                elif 330 < ID <= 390: self.type = "EARTH"
                elif 390 < ID <= 440: self.type = "ICE"
                elif 440 < ID <= 515: self.type = "FIRE"
                elif 515 < ID <= 556: self.type = "ELECTRIC"
                elif 556 < ID <= 611: self.type = "ROBOT"
                elif 611 < ID <= 661: self.type = "DINO"
                elif 661 < ID <= 726: self.type = "UNDEAD"
                elif 726 < ID <= 776: self.type = "DEMONIC"
                elif 776 < ID <= 837: self.type = "HOLY"
                elif 837 < ID <= 887: self.type = "TITAN"
                elif ID == 888: self.type = "NONE" #special case for "Desperation"
                else: raise ValueError("No move type specified!")
                for i in range(len(item)): #for each column
                    values[MovesDB[0][i]] = item[i] #add the values into the list as a DB
                print("Successfully retrieved values!")
                return values
            else:
                continue
        print("No move loaded!")                                                                                                                                     